/****************************************/
/*** Copyright (c) 2024, Egor Demidov ***/
/****************************************/

#include <iostream>
#include <fstream>

#include "writer.h"
#include "exception.h"

void dump_necks(std::string const & dir, size_t count, std::vector<Eigen::Vector3d> const & x,
                std::vector<bool> const & bonded_contacts, double r_part) {

    std::stringstream out_file_name;
    out_file_name << dir << "/necks_" << count << ".vtk";
    std::ofstream ofs(out_file_name.str());

    if (!ofs.good())
        throw DemException("Unable to create a dump file at " + out_file_name.str());

    size_t neck_count = std::count(bonded_contacts.begin(), bonded_contacts.end(), true) / 2u;

    ofs << "# vtk DataFile Version 4.0" << "\n";
    ofs << "Generated by libgran" << "\n";
    ofs << "ASCII" << "\n";
    ofs << "DATASET POLYDATA" << "\n";
    ofs << "POINTS " << neck_count << " FLOAT" << "\n";

    for (size_t i = 0; i < x.size() - 1; i ++) {
        for (size_t j = i + 1; j < x.size(); j ++) {
            if (!bonded_contacts[i * x.size() + j])
                continue;

            // This is a bonded contact
            Eigen::Vector3d position = (x[j] + x[i]) / 2.0 / r_part; // Compute the position

            ofs << position[0] << " " << position[1] << " " << position[2] << " ";
        }
    }

    ofs << "\n" << "\n";
    ofs << "POINT_DATA " << neck_count << "\n";
    ofs << "FIELD FieldData 2" << "\n";
    ofs << "normals 3 " << neck_count << " double" << "\n";
    for (size_t i = 0; i < x.size() - 1; i ++) {
        for (size_t j = i + 1; j < x.size(); j ++) {
            if (!bonded_contacts[i * x.size() + j])
                continue;

            // This is a bonded contact
            Eigen::Vector3d orientation = (x[j] - x[i]).normalized(); // Compute the orientation vector

            ofs << orientation[0] << " " << orientation[1] << " " << orientation[2] << " ";
        }
    }
    ofs << "\n";
    ofs << "connections 2 " << neck_count << " int" << "\n";  // Tuples of 2 to avoid errors with ParaView
    for (size_t i = 0; i < bonded_contacts.size(); i ++) {
        if (bonded_contacts[i])
            ofs << i << " ";
    }
    ofs << "\n\n";
}

// Overload to write particle positions without velocities and orientations
void dump_particles(std::string const & name, std::vector<Eigen::Vector3d> const & x, double r_part) {
    std::stringstream out_file_name;
    out_file_name << name << ".vtk";
    std::ofstream ofs(out_file_name.str());

    if (!ofs.good())
        throw DemException("Unable to create a dump file at " + out_file_name.str());

    ofs << "# vtk DataFile Version 4.0" << "\n";
    ofs << "Generated by libFractalCommon" << "\n";
    ofs << "ASCII" << "\n";
    ofs << "DATASET POLYDATA" << "\n";
    ofs << "POINTS " << x.size() << " FLOAT" << "\n";

    // Coordinates are normalized to avoid issues with ParaView and small particles
    for (auto const & p : x) {
        ofs << p[0] / r_part << " " << p[1] / r_part << " " << p[2] / r_part << " ";
    }
    ofs << "\n";
}

void dump_particles(std::string const & dir, size_t count, std::vector<Eigen::Vector3d> const & x,
                    std::vector<Eigen::Vector3d> const & theta,
                    std::vector<Eigen::Vector3d> const & v,
                    std::vector<Eigen::Vector3d> const & a,
                    std::vector<Eigen::Vector3d> const & omega,
                    std::vector<Eigen::Vector3d> const & alpha,
                    double r_part) {
    std::stringstream out_file_name;
    out_file_name << dir << "/particles_" << count << ".vtk";
    std::ofstream ofs(out_file_name.str());

    if (!ofs.good())
        throw DemException("Unable to create a dump file at " + out_file_name.str());

    ofs << "# vtk DataFile Version 4.0" << "\n";
    ofs << "Generated by libFractalCommon" << "\n";
    ofs << "ASCII" << "\n";
    ofs << "DATASET POLYDATA" << "\n";
    ofs << "POINTS " << x.size() << " FLOAT" << "\n";

    // Coordinates are normalized to avoid issues with ParaView and small particles
    for (auto const & p : x) {
        ofs << p[0] / r_part << " " << p[1] / r_part << " " << p[2] / r_part << " ";
    }

    ofs << "\n\n";
    ofs << "POINT_DATA " << x.size() << "\n";
    ofs << "FIELD FieldData 7" << "\n";
    ofs << "v 1 " << x.size() << " double\n";
    for (auto const & p : v) {
        ofs << p.norm() << " ";
    }
    ofs << "\n";
    ofs << "a 1 " << x.size() << " double\n";
    for (auto const & p : a) {
        ofs << p.norm() << " ";
    }
    ofs << "\n";
    ofs << "omega 1 " << x.size() << " double\n";
    for (auto const & p : omega) {
        ofs << p.norm() << " ";
    }
    ofs << "\n";
    ofs << "alpha 1 " << x.size() << " double\n";
    for (auto const & p : alpha) {
        ofs << p.norm() << " ";
    }
    ofs << "\n";
    ofs << "thetax 3 " << x.size() << " double\n";
    for (auto const & t : theta) {
        Eigen::Matrix3d m;
        m = Eigen::AngleAxis(t[0], Eigen::Vector3d::UnitX())
            * Eigen::AngleAxis(t[1], Eigen::Vector3d::UnitY())
            * Eigen::AngleAxis(t[2], Eigen::Vector3d::UnitZ());

        auto unit = Eigen::Vector3d::UnitX();
        auto orient = m*unit;

        ofs << orient[0] << " " << orient[1] << " " << orient[2] << " ";
    }
    ofs << "\n" << "thetay 3 " << x.size() << " double" << "\n";
    for (auto const & t : theta) {
        Eigen::Matrix3d m;
        m = Eigen::AngleAxis(t[0], Eigen::Vector3d::UnitX())
            * Eigen::AngleAxis(t[1], Eigen::Vector3d::UnitY())
            * Eigen::AngleAxis(t[2], Eigen::Vector3d::UnitZ());

        auto unit = Eigen::Vector3d::UnitY();
        auto orient = m*unit;

        ofs << orient[0] << " " << orient[1] << " " << orient[2] << " ";
    }
    ofs << "\n" << "thetaz 3 " << x.size() << " double" << "\n";
    for (auto const & t : theta) {
        Eigen::Matrix3d m;
        m = Eigen::AngleAxis(t[0], Eigen::Vector3d::UnitX())
            * Eigen::AngleAxis(t[1], Eigen::Vector3d::UnitY())
            * Eigen::AngleAxis(t[2], Eigen::Vector3d::UnitZ());

        auto unit = Eigen::Vector3d::UnitZ();
        auto orient = m*unit;

        ofs << orient[0] << " " << orient[1] << " " << orient[2] << " ";
    }
}

void dump_particles(std::string const & dir, size_t count, std::vector<Eigen::Vector3d> const & x,
                    std::vector<Eigen::Vector3d> const & v,
                    std::vector<Eigen::Vector3d> const & a,
                    std::vector<Eigen::Vector3d> const & omega,
                    std::vector<Eigen::Vector3d> const & alpha,
                    double r_part) {
    std::stringstream out_file_name;
    out_file_name << dir << "/particles_" << count << ".vtk";
    std::ofstream ofs(out_file_name.str());

    if (!ofs.good())
        throw DemException("Unable to create a dump file at " + out_file_name.str());

    ofs << "# vtk DataFile Version 4.0" << "\n";
    ofs << "Generated by libFractalCommon" << "\n";
    ofs << "ASCII" << "\n";
    ofs << "DATASET POLYDATA" << "\n";
    ofs << "POINTS " << x.size() << " FLOAT" << "\n";

    // Coordinates are normalized to avoid issues with ParaView and small particles
    for (auto const & p : x) {
        ofs << p[0] / r_part << " " << p[1] / r_part << " " << p[2] / r_part << " ";
    }

    ofs << "\n\n";
    ofs << "POINT_DATA " << x.size() << "\n";
    ofs << "FIELD FieldData 4" << "\n";
    ofs << "v 1 " << x.size() << " double\n";
    for (auto const & p : v) {
        ofs << p.norm() << " ";
    }
    ofs << "\n";
    ofs << "a 1 " << x.size() << " double\n";
    for (auto const & p : a) {
        ofs << p.norm() << " ";
    }
    ofs << "\n";
    ofs << "omega 1 " << x.size() << " double\n";
    for (auto const & p : omega) {
        ofs << p.norm() << " ";
    }
    ofs << "\n";
    ofs << "alpha 1 " << x.size() << " double\n";
    for (auto const & p : alpha) {
        ofs << p.norm() << " ";
    }
    ofs << "\n";
}
